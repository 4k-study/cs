# Dispatcher-Servlet이란?

dispatch라는 의미는 보내다라는 의미입니다. 디스패처 서블릿은 요청을 HTTP 프로토콜로 들어오는 모든 요청을 가장 먼저 받아서 알맞은 컨트롤러에게 위임하는 프론트 컨트롤러다라고 정의할 수있습니다. 

### 장점

기존에는 서블릿 컨테이너에서 web.xml을 기반으로 사용자가 요청한 URL이 어느 서블릿에 대한 요청인지를 찾았습니다.

디스패처 서블릿이 등장하고 나서는 애플리케이션으로 들어오는 모든 요청을 디스패처 서블릿이 핸들링하고 공통 작업을 처리를 해줘서 컨트롤러만 구현해두면 디스패처 서블릿이 알아서 요청을 위임하는 구조가 되었습니다. 

### 정적 자원의 처리

디스패처 서블릿을 이용하면 상당히 효율적이지만 정적 파일에 대한 요청마저도 받는 바람에 정적 파일을 불러오지 못하는 상황도 발생했고 이를 해결하기 위해서 정적 자원 요청과 애플리케이션 요청을 분리하거나 애플리케이션 요청을 탐색 후 없으면 정적 자원 요청으로 처리하는 방식을 고안했습니다.

그러나 첫 번째 방식인 url을 분리하는 것은 너무 지저분해지고 직관적 설계가 어려워 애플ㄹ케이션 요청 탐색 후에 없으면 정적 자원 요청으로 처리하는 방식을 많이 사용하게 되었습니다.

### 동작 방식

디스패처 서블릿은 적합한 컨트롤러와 메서드를 찾아서 요청을 위임해야 합니다.

그러기 위해서 서블릿이 요청을 받으면 해당 요청을 위임할 컨트롤러를 찾고 핸들러 어댑터를 찾아서 전달하고 핸들러 어댑터가 컨트롤러로 요청을 위임합니다.

그 후, 비즈니스 로직이 수행되고 컨트롤러가 반환값을 위임 후 어댑터에게 넘기고 어댑터가 처리한 응답값을 디스패처 서블릿을 통해서 클라이언트로 반환합니다.

- 컨트롤러 찾기
    - 컨트롤러 어노테이션과 리퀘스트 매핑 관련 어노테이션을 조합해서 컨트롤러를 찾게 되는데 주로 핸들러 매핑의 구현체 중 하나인 RequestMappingHandlerMapping이 찾아줍니다. 해당 객체의 내부는 HashMap 구조로 이루어져있고 요청 정보와 처리 대상을 관리합니다.
    - 이렇게 찾아진 요청을 처리할 대상은 컨트롤러가 아니라 HandlerMethod입니다. 이는 컨트롤러와 컨트롤러 메서드를 포함한 부가적인 정보들이 들어있고 이를 HandlerMethodExecutionChain으로 감싸서 반환화하는데 그 이유는 컨트롤러로 요청을 넘기기 전에 인터셉터와 같은 친구들을 거치기 위해서 입니다.
- 핸들러 어댑터에게 위임.
    - 컨트롤러로 직접 위임하지 않고 핸들러 어댑터를 거치는 이유는 컨트롤러의 구현 방식이 다향하기 때문입니다. 과거에는 인터페이스로 구현했지만 지금은 어노테이션 기반으로 구현하기 때문에 이 구현 방식에 상관없이 요청이 가능하기 위해서 어댑터를 거쳐서 요청을 위임합니다.
- 핸들러 어댑터가 컨트롤러로 요청을 위임.
    - 컨트롤러로 요청을 넘기기 전에 전처리 과정이 필요합니다. 인터셉터도 실행 시키고 @RequestParam, @RequestBody와 같이 파라미터를 준비하는 ArgumentResolver도실행하는 등의 다양한 공통 작업들이 수행됩니다. 이런 작업이 완료되면 파라미터 값과 함께 컨트롤러로요청을 위임합니다.
- 핸들러 어댑터가 반환값을 처리.
    - ReturnValueHandler가 후처리한 후에 디스패처 서블릿으로 돌려줍니다. ResponseEntity를 반환하면 HttpEntityMethodProcessor가 MessageConverter를 사용해서 응답 객체를 직렬화하고 응답 상태를 설정합니다.
