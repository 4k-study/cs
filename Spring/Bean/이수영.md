# 스프링 빈이란?

스프링 빈은 스프링 컨테이너에 의해서 관리되는 자바 객체(POJO)를 의미합니다.

### 스프링 컨테이너

스프링 컨테이너는 스프링 빈의 생명 주기를 관리하며 스프링 빈들에게 추가적인 기능을 제공하느 역할을 수행합니다. IoC와 DI의 원리가 스프링 컨테이너에 적용됩니다.

개발자가 직접 new 연산자, 인터페이.스 호출, 팩토리 호출 방식으로 객체를 생성하는 것처럼 스프링 컨테이너에서 이를 대신해줍니다. 즉, 제어의 흐름을 외부에서 관리하게 되고 의존관계 또한 스프링 컨테이너에서 런타임에 설정해줍니다

### 스프링 빈 등록 방식

- Component Scan
    
    : @Component를 명시하여 빈을추가하는 방법입니다. 클래스 위에 어노테이션을 붙이면 스프링에서 알아서 스프링 컨테이너에 빈을 등록합니다. 많이 사용되는 @Service, @Controller, @Repository 어노테이션들도 @Component 어노테이션을 상속 받고 있어 컴포넌트 스캔의 대상이 됩니다.
    
- Java 코드로 등록
    
    : Java 코드로도 빈을 등록할 수 있는데 클래스를 생성하고 @Configuration을 이용하여 빈을 등록합니다. 해당 클래스 내부에서는 @Bean 어노테이션을 이용해서 빈으로 등록할 객체들의 인스턴스를 생성하는 메서드에 붙여줍니다. @Configuration도 @Component를 상속하여 컴포넌트 스캔의 대상이 됩니다.
    
- 수동 등록
    
    : 거의 사용하진 않지만 ApplicationContext를 호출해서 수동으로 설정 파일을 이용하면 빈을 수동 등록이 가능합니다. 
    

### @Bean vs @Component

- Bean
    
    : 이는 자바 코드를 이용하는 방식으로써 개발자가 컨트롤 불가한 외부 라이브러리들을 Bean으로 등록하고 싶을 때 @Component를 해당 라이브러리에 가서 붙일 수 없으니까 자바 코드를이용하여 등록합니다. 메소드 또는 어노테이션 단위에만 붙일 수 있습니다.
    
- Component
    
    : Bean과는 반대로 개발자가 직접 컨트롤 할 수 있는 클래스들의 경우에 사용합니다. 클래스 또는 인터페이스 단위에만 붙일 수 있습니다. 
    

### @Configuration과 싱글톤

@Configuration은 @Bean에 추가 설정을 주지 않는 이상 무조건 빈에 대해 싱글톤을 보장합니다.

메서드가 2번 실행된다 하더라도 다른 인스턴스를 이용하는 것이 아니라 하나의 인스턴스를 이용하게됩니다.

그 이유는 CGLIB (Code Generator Library)를 사용해서 클래스의 바이트 코드를 조작해 빈 등록 시 프록시 객체를 등록함으로써 싱글톤을 보장합니다. 

### Bean Lite Mode

Bean Lite Mode는 CGLib를 이용하여 바이트 코드 조작을 하지 않는 방식을 의미합니다. 즉, 스프링 빈의 싱글톤을 보장하지 않습니다.

이를 설정하기 위해선 자바 코드를 이용하여 @Bean을 통해 빈을 등록할 때처럼 구성하되 @Configuration을 @Component로 변경하면 됩니다. 그럼 objectMapperLiteBean() 이란 메서드를 lite mode로 작동시켜 매번 다른 객체를 반환해줄 수 있습니다. 

### 스프링 빈 스코프

스프링은 싱글톤과 프로토타입 빈 스코프를 제공하고 있고 스프링 MVC 웹 애플리케이션을 사용할 경우 웹 스코프를 제공합니다.

- 싱글톤
    - 싱글톤 빈은 스프링 컨테이너에서 한 번만 생성되고 컨테이너와 생명 주기가 같습니다
    - 생성된 하나의 인스턴스는 Spring Beans Cache에 저장됩니다.
    - default 빈 스코프입니다.
    - 싱글톤 타입으로 적합한 객체
        - 상태가 없는 공유 객체
        - 읽기 전용으로만 상태를 가진 객체
        - 쓰기가 가능한 상태를 지니면서도 사용 빈도가 매우 높은 객체
            - 단, 이때는 동기화 전략 필요
- 프로토타입
    - 프로토타입 빈은 DI 발생 시 마다 새로운 객체가 생성되어 주입됩니다.
    - 빈 소멸에 스프링 컨테이너가 관여하지 않고 gc에 의해 제거됩니다.
    - 대상 클래스에 Scope(”prototype”)을  붙이면 됩니다.
    - 프로토타입으로 적합한 객체
        - 사용할 때마다 상태가 달라져야 하는 객체
        - 쓰기가 가능한 상태가 있는 객체

### 싱글톤 빈과 프로토타입 빈을 같이 사용할 때 생기는 문제

싱글톤 객체가 프로토 타입 객체를 가지고 있는 경우 의도한 것과 다른 결과가 발생할 수 있습니다. 이미싱글톤 빈으로 생성되는 시점에 프로토 타입 빈이 생성되어 들어오기 때문에 싱글톤 빈 내부의 프로토 타입 빈을 호출하면 매번 같은 값을 가져옵니다. 만약 싱글톤 빈 내부의 프로토 타입 빈을 사용할 때마다 다른 인스턴스를 받아오려면 어떻게 해야 할까요?

1. Provider : logic() 메서드를 호출 시 마다 다른 프로토타입 빈 인스턴스가 호출됩니다.
2. @Scope의 proxyMode 설정

### 웹 스코프

웹 스코프는 웹 환경에서만 동작하는 스코프이고 프로토 타입과 다르게 특정 주기가 끝날때까지 관리를 해준다. 따라서 @PreDestory와같은 소멸 콜백이 호출된다는 특징이 있다.

- 웹 스코프의 종류
    - Request
        - HTTP 요청 하나가 들어오고 나갈 때까지 유지되는 스코프
        - 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고 관리된다.
    - Session
        - HTTP Session과 동일한 생명 주기를 가지는 스코프
    - Application
        - 서블릿 컨텍스트와 동일한 생명 주기를 가지는 스코프
    - WebSocket
        - 웹 소켓과 동일한 생명 주기를 가지는 스코프
