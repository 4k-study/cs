<details>
<summary>AOP 에 대해서 설명해주세요</summary>
<div markdown="1">  
AOP 란 비즈니스 로직과 공통 관심사 로직을 분리할 수 있도록 해주는 기술입니다. <br>
비즈니스 로직은 아니지만 서비스에 필수적인 로그, 트랜잭션 관련 로직들을 비즈니스 로직과 분리하여 비즈니스 로직의 응집성을 높이고 유지보수하기 쉽게 만듭니다.
</div>
</details>

<details>
<summary>AOP 사용해본 적 있나요?</summary>
<div markdown="1">  
네, 내부적으로 AOP 를 사용하는 @Transactional 어노테이션과 Slf4j 를 이용해본 경험이 있습니다.
</div>
</details>

<details>
<summary>트랜잭션에서 AOP 사용하는 방식</summary>
<div markdown="1">  
프록시를 기반으로 동작합니다. Spring 의 경우 다이나믹 프록시, Spring Boot 의 경우 CGLIB 을 기반으로 프록시 객체를 생성합니다. <br>
프록시 객체가 타겟 객체로 오는 요청을 가로채서 트랜잭션과 관련된 로직을 실행하고 다시 타겟 객체를 호출하여 타겟 객체의 로직을 수행하도록 합니다. <br>
프록시 객체에서 트랜잭션 로직을 실행하여 타겟 객체는 트랜잭션 관련 로직을 전혀 알지 않아도 되는 장점이 있습니다.
</div>
</details>

<details>
<summary>리플렉션에 대해서 말해주세요</summary>
<div markdown="1">  
구체적인 클래스 타입을 알지 못해도 그 클래스의 정보에 접근할 수 있게 해주는 자바의 API 입니다. <br>
컴파일된 바이트 코드를 분석하는 방식으로 클래스 정보에 접근합니다. <br>
유연하게 코드를 작성할 수 있다는 장점이 있습니다. <br>
단점으로는 런타임 환경에서 바이트 코드에서 클래스 정보를 가져오게 되므로 잦은 사용은 성능 저하를 야기할 수 있고, private 인 필드, 메서드에도 접근할 수 있으므로 내부가 노출될 수 있습니다.
</div>
</details>

<details>
<summary>리플렉션의 단점을 상쇄하려고 스프링에서 사용하는 방식</summary>
<div markdown="1">  
어플리케이션 로딩 시점에 전부 로딩하고, 최대한 런타임 환경에서 추가로 로딩하지 않도록 동작합니다.
</div>
</details>

<details>
<summary>AOP 에서 어떨때 다이내믹 프록시가 사용되고 어떨때 cglib 이 사용되는지</summary>
<div markdown="1">  
보통 Spring 은 다이내믹 프록시, Spring Boot 는 cglib 을 기본으로 사용합니다. <br>
다이나믹 프록시와 cglib 이 프록시를 만드는 방식을 이야기해보자면, <br>
다이나믹 프록시는 target 의 상위 인터페이스를 기반으로 프록시 객체를 만듭니다. <br>
cglib 은 target 클래스를 상속받아 프록시 객체를 만듭니다.
</div>
</details>

<details>
<summary>디스패처 서블릿에 대해서 알려주세요</summary>
<div markdown="1">  
스프링 MVC 에서 프론트 컨트롤러 역할을 합니다. <br>
모든 요청이 디스패처 서블릿을 거치고 그 후 각 요청에 맞는 핸들러를 찾는 방식으로 동작하기에 공통 로직을 디스패처 서블릿에서 실행하여 반복되는 로직을 줄일 수 있습니다. <br>
또, 각 요청마다 서블릿을 만들어주지 않아도 되게 해줍니다.
</div>
</details>

<details>
<summary>핸들러 어댑터 존재 이유</summary>
<div markdown="1">  
다양한 형태의 핸들러가 존재하기 때문입니다. <br>
어떤 개발자는 Controller 인터페이스를 구현하는 방식의 핸들러를 구현하고 싶을 수 있고, 또 다른 개발자는 애노테이션 기반의 핸들러를 구현하고 싶을 수 있습니다. <br>
이와 같이 개발자마다 핸들러를 구현하는 방식이 다를 수 있는데, 이런 모든 요구 사항을 맞추기 위해서 어댑터가 필요합니다.
</div>
</details>

<details>
<summary>트랜잭션에 대해서 알려주세요</summary>
<div markdown="1">  
데이터베이스 작업의 논리적 단위입니다. <br>
크게 4가지 성질을 가집니다. <br>
원자성(Atomicity): 트랜잭션은 하나의 논리적인 작업 단위로, 모든 연산이 반영되거나 전혀 반영되지 않아야 합니다. <br>
일관성(Consistency): 트랜잭션이 실행을 성공적으로 완료하면, 데이터베이스는 일관된 상태가 되어야 합니다. 즉, 트랜잭션이 일어난 이후의 데이터베이스는 데이터베이스의 제약이나 규칙을 만족해야 한다는 뜻입니다. <br>
격리성(Isolation): 둘 이상의 트랜잭션이 동시에 실행될 때 각각의 트랜잭션은 다른 트랜잭션의 연산에 영향을 받지 않아야 합니다. <br>
지속성(Durability): 트랜잭션이 성공적으로 완료되면, 해당 결과는 영구적으로 데이터베이스에 반영되어야 합니다. 
</div>
</details>

<details>
<summary>트랜잭션 교착상태에 대해서 알려주세요</summary>
<div markdown="1">  
여러 개의 트랜잭션이 자원을 점유한 상태에서 상호 간에 필요로 하는 추가적인 자원을 얻지 못해 무한히 대기하는 상황을 말합니다
</div>
</details>

<details>
<summary>트랜잭션 교착상태 예방법</summary>
<div markdown="1">  
트랜잭션의 진행방향을 한 방향으로만 진행되도록 하거나, 트랜잭션 획득 대기 시간을 설정해주는 방식이 있습니다.
</div>
</details>

<details>
<summary>HashMap 은 무엇인가요?</summary>
<div markdown="1">  
key, value 형태로 데이터를 저장합니다. key 는 맵에 유일하게 있어야 되고 중복을 허용하지 않지만,  value 는 중복된 값이어도 상관 없습니다. <br>
내부적으로 해시 테이블을 사용하여 데이터를 저장하고 검색합니다. key 를 해시 함수에 적용하여 해시 코드를 생성하고, 해당 해시 코드를 인덱스로 사용하여 데이터를 저장하고 검색합니다. <br>
조회 및 저장 시 시간복잡도가 O(1) 이기에 대규모 데이터를 처리하는 것에 유리합니다. <br>
다만, 순서와 동기화를 보장하지 않기에 순서를 보장해야하거나 여러 스레드에서 접근해야한다면 다른 자료구조를 이용하는 것이 좋습니다.

</div>
</details>
