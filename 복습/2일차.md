- 스프링에서의 프록시에 대해서 설명해주세요
```
스프링에서의 프록시는 AOP(Aspect-Oriented Programming) 구현에 사용되는 개념입니다. AOP는 핵심 비즈니스 로직과 공통적으로 사용되는 부가적인 기능(로깅, 트랜잭션 관리, 보안 등)을 분리하여 모듈화하는 프로그래밍 접근 방식입니다. 프록시는 핵심 로직을 감싸고, 필요한 부가 기능을 제공하면서도 핵심 로직에 대한 수정 없이 기능을 확장할 수 있도록 도와줍니다. 스프링은 다이내믹 프록시(Dynamic Proxy)를 활용하여 AOP를 구현합니다.
```

- JDK 동적 프록시와 CGLIB가 프록시 객체를 생성하는 방법의 차이가 뭔가요?
```
JDK 동적 프록시는 자바의 리플렉션을 사용하여 프록시 객체를 생성합니다.
CGLIB는 바이트 코드를 조작하여 프록시 객체를 생성합니다.
```

- 스프링 빈에대해서 설명해주세요
```
스프링 빈은 스프링 프레임워크가 관리하는 객체입니다. 스프링 빈은 스프링 컨테이너에 의해 생성되고, 관리되며, DI(Dependency Injection)를 통해 필요한 곳에서 사용됩니다. 스프링 빈은 @Component, @Service, @Repository, @Controller 등의 어노테이션을 사용하여 정의할 수 있습니다. 스프링 빈은 싱글톤(Singleton) 스코프로 기본 설정되어 있으며, 스프링 컨테이너의 생명 주기에 맞게 생성 및 소멸됩니다.
```
- @Repository, @Service, @Controller 차이점
```
@Repository: 데이터 접근 계층(DAO, Repository)의 구현 클래스에 사용됩니다. 데이터베이스와의 상호 작용을 담당합니다. DB마다 다른 에러를 추상화시켜 제공합니다.
@Service: 비즈니스 로직을 처리하는 서비스 클래스에 사용됩니다. 주로 트랜잭션 처리와 같은 비즈니스 로직을 담당합니다.
@Controller: 웹 애플리케이션에서 웹 요청을 처리하는 컨트롤러 클래스에 사용됩니다. 주로 클라이언트 요청을 처리하고 응답을 반환하는 역할을 합니다.
```

- 빈 수동등록 하는경우
```
수동 등록을 선택하는 이유는 특정 라이브러리나 외부 구성 요소와의 연동이 필요하거나, 복잡한 설정을 해야할 경우 등이 있을 수 있습니다.
```

- HashTable과 HashMap의 차이점
```
1. 동기화
HashTable은 동기화를 지원하기 때문에 Thread-safe하고, HashMap은 Thread-safe하지 않다는 특징을 가지고 있습니다. 그렇기에 멀티스레드 환경이 아니라면 Hashtable은 HashMap 보다 성능이 떨어진다는 단점을 가지고 있습니다.
2. Null 허용
Hashtable은 key에 null을 허용하지 않지만, HashMap은 key에 null을 허용합니다.
```

- GC 알고리즘 아는거 하나 설명해주세요
    
    ```
    먼저 GC는 자동 메모리 관리의 한 형태로 사용, 참조되지 않는 메모리들을 할당 해제하여
    관리를 함으로써 개발자가 메모리 할당/해제에 대한 수동 관리의 부담을 덜어줍니다.
    모든 GC들은 Mark, Sweep, Compact를 기반으로 동작합니다. 참조되지 않는 객체들을 식별하고
    마킹된 객체를 제거하고 이 작업으로 발생한 메모리 단편화를 없애는 compact를 수행합니다.
    자바에서 지원하는 GC 알고리즘 중에 JDK 17에서 default로 이용하는 G1 GC에 대해서 설명하
    겠습니다. G1은 힙 메모리 영역을 Region으로 나누어서 관리를 하고 이 Region의 크기는 JVM
    에서 판다하여 일반적으로 1MB ~ 32MB로 할당합니다. 이 Region은 Eden, Survivor, Old 제너레이션
    영역의 논리적인 표현으로 매핑됩니다.
    1. Young GC를 수행합니다.
    2. Survivor 영역을 스캔하면서 Old 영역으로 승격시킵니다.
    3. 앱을 실행하면서 전체 힙에서 Live 객체를 찾습니다.
    4. 앱이 실행되는 동안 변경될 수 있기에 다시 Live 객체를 찾습니다.
    5. 마킹한 객체들을 할당 해제합니다.
    G1은 Compact가 발생하지 않는 특징을 가집니다. 그 이유는 Region의 크기를 조절할 수 있고
    영역을 논리적으로 표현하여 연속될 필요가 없기 때문입니다.
    ```
    
- 영속성 컨텍스트에 대해서 설명해주세요
    
    ```
    영속성 컨텍스트는 엔티티를 관리하는 환경입니다. 트랜잭션마다 EntityManager를 생성해서 
    영속성 컨텍스트에 접근합니다. 그래서 트랜잭션과 생명주기가 같습니다.
    영속성 컨텍스트가 하는 일은
    1. 엔티티 생명주기 관리 : 영속성 컨텍스트는 엔티티 생성부터 삭제까지의 생명주기를 관리합니다.
    엔티티 객체를 영속성 컨텍스트에 저장하면 해당 객체는 영속 상태가 되고 DB와의 일관성 유지를
    위해서 관리됩니다.
    2. 지연 로딩 (Lazy Loading) : 엔티티를 필요한 시점까지 미뤄서 조회합니다. 이를 통해서 성능을
    최적화할 수 있고 예시로 엔티티의 연관관계에 페치 전략을 지연 로딩으로 설정하면 연관된 엔티티가
    실제로 사용되는 시점에 조회합니다.
    3. 동일성 보장 : 동일한 식별자(pk)를 가진 엔티티에 대해서 동일한 인스턴스를 반환하여 동일성을
    보장합니다. 애플리케이션에서 엔티티를 동일성 비교할 때 편리하게 사용가능합니다.
    4. 변경 감지 (Dirty Checking) : 엔티티의 변경 사항을 감지하여 자동으로 DB에 반영합니다. 변경된
    엔티티는 커밋 시점에 DB에 자동으로 동기화됩니다.
    5. 트랜잭션 범위 관리 : 트랜잭션이 시작될 때 영속성 컨텍스트가 생성되고 종료될 때 DB에 커밋
    하면서 영속성 컨텍스트가 종료됩니다. 이를 통해서 트랜잭션 단위로 일관된 DB 상태를 유지할 수
    있습니다.
    
    ```
    
    - 더티체킹 과정에 대해서 설명해주세요
        
        ```
        엔티티를 영속성 컨텍스트 1차 캐시에 반영할 때 스냅샷이라고 하는 최초 상태를 복사해서
        저장해둡니다. 그리고 플러시 시점에 스냅샷과 엔티티 상태를 비교해서 변경된 엔티티를 찾고
        변경된 엔티티가 존재하는 경우에 수정 쿼리를 통해서 쓰기 지연 SQL 저장소에 보내고
        트랜잭션이 커밋될 때 쓰기 지연 SQL 저장소의 모든 쿼리를 DB에 반영하게 됩니다.
        ```
        
- DB 트랜잭션의 정의와 특징에 대해서 설명해주세요.
    
    ```
    트랜잭션은 DB에서 이루어지는 작업의 최소단위로 DB의 무결성을 유지하며 DB의 상태를 변화시키는
    기능을 수행합니다.
    트랜잭션은 4가지 성질을 가집니다.
    1. Atomicity, 원자성 : 트랜잭션은 작업의 최소단위이기에 더 이상 쪼개질 수 없기에 작업이 
    전부 수행되거나 전부 수행되지 않아야 합니다.
    2. Consistency, 일관성 : 트랜잭션이 성공했을 때 언제나 일관된 DB 상태를 유지해야 한다는
    성질입니다. 예로 송금 전후의 잔액이 모두 Integer 타입이어야 하는 것을 들 수 있습니다.
    3. Isolation, 고립성 : 여러 트랜잭션은 동시에 수행 되는데 각 트랜잭션은 다른 트랜잭션의
    연산 작업이 끼어들지 못하도록 보장하여 독립적으로 작업을 수행합니다. 따라서 같은 data에 
    대해서 동시에 접근하여 충돌하지 않도록 제어해야 하고 이를 동시성 제어라고 합니다.
    4. Durability, 지속성 : 성공적으로 수행된 트랜잭션은 DB에 영원히 반영되어야 합니다.
    트랜잭션이 완료되어 저장된 DB는 저장 후에 생기는 정전, 장애, 오류 등에 영향을 받지 않아야
    합니다.
    ```
    
    - 트랜잭션의 고립성이 너무 철저히 지켜질 때 발생할 수 있는 문제를 말해주세요.
        
        ```
        트랜잭션의 고립성은 각 트랜잭션이 다른 트랜잭션의 연산에 관여하지 않고 독립적으로
        작업을 수행하는 것을 의미하는데 이것이 굉장히 철저하게 지켜지면 동시성이 감소하게 됩니다.
        동시성은 병렬적으로 처리되는 것처럼 작업을 수행하는 것을 의미하는데 이것이 감소하게 되면
        결국 직렬적으로 작업을 수행하게 될 것이고 그럼 하나의 트랜잭션씩 수행하게 되는 문제가
        발생하게 됩니다.
        ```
