# ArrayList vs LinkedList

## ArrayList

<aside>
💡 연관된 data를 **메모리 상에 연속적이고 순차적으로 미리 할당된 크기만큼** 저장하는 자료구조

</aside>

### 특징

- 고정된 저장 공간 (fixed-size)
- 순차적인 데이터 저장

Array의 장점은 조회가 빠르다는 것이다. 따라서 조회를 자주 해야되는 작업에서는 Array 자료구조를 많이 사용한다.

반면에 Array의 단점은 고정된 저장 공간을 가지고 있기 때문에 선언 시 Array의 크기를 미리 결정해야 한다는 것이다. 이는 메모리 낭비와 추가적인 오버헤드가 발생할 수 있다.

### 시간 복잡도

|  | Array |
| --- | --- |
| access | $O(1)$ |
| append | $O(1)$ |
| 마지막 원소delete | $O(1)$ |
| insertion | $O(n)$ |
| deletion | $O(n)$ |
| search | $O(n)$ |

**조회(Look up)**

메모리 상에서 연속적으로 데이터를 저장했기 때문에 데이터에 **즉시 접근(random access)**이 가능하다. 따라서 O(1)의 시간복잡도를 가진다.

**삽입/삭제**

맨 뒤에 원소를 추가/삭제하면 O(1)의 시간복잡도를 가진다. 하지만 중간에 데이터를 삽입/삭제하는 연산은 해당 원소보다 큰 인덱스를 가지는 원소들을 한 칸씩 shift 해줘야 하기 때문에 O(N)의 시간복잡도를 가진다.

## LinkedList

<aside>
💡 LinkedList는 노드라는 구조체로 이루어져 있는데, 노드는 **데이터 값**과 **다음 노드의 주소**를 저장한다. LinkedList는 **메모리 상에서는 비연속적**으로 저장이 되지만 LinkedList를 구성하는 각각의 노드가 다음 노드의 주소를 가리킴으로써 **논리적인 연속성**을 가진 자료구조이다.

</aside>

### 시간복잡도

Array의 경우는 물리적인 메모리에서의 연속성 때문에 중간에 데이터를 삽입/삭제 하게되면 해당 인덱스의 뒤에있는 모든 원소를 shift 해줘야 했기 때문에 O(n)의 시간복잡도를 가지지만 

LinkedList는 물리적으로 원소들을 shift 해줄 필요가 없이 노드가 가리키는 다음 노드의 주소값만 변경해주면 되기 때문에 데이터 삽입/삭제 연산 시 O(1)의 시간복잡도를 가진다.

|  | Linked list |
| --- | --- |
| access | $O(n)$ |
| search | $O(n)$ |
| insertion | $O(1)$ |
| deletion | $O(1)$ |

**조회(Look up)**

메모리 상에서 불연속적으로 데이터를 저장하기 때문에 순차 접근(Sequential Access)만 가능하다. 따라서 특정 인덱스의 데이터를 조회하기 위해 O(N)의 시간이 걸린다.

**삽입/삭제**

어느 원소를 추가/삭제 하더라도 노드에서 다음 주소를 가리키는 부분만 다른 주소 값으로 변경하면 되기 때문에 shift 할 필요가 없어 O(1)의 시간복잡도를 가진다. 하지만 추가/삭제하려는 인덱스까지 도달하는데 O(N)의 시간이 걸리기 때문에 실질적으로 O(N)의 시간이 걸린다고 할 수 있다.
