# 힙

- 자식 노드 보다 큰 / 작은 부모노드의 관계를 유지하는 노드들로 이루어진 완전 이진 트리
- 반정렬 상태 유지 : 반 정렬 상태란 부모 노드와 자식 노드의 관계만 신경 쓰고, 
형제 간 우선순위는 고려하지 않는다.
- 최대값 / 최솟값을 찾기 위해 $O(1)$ 의 시간 복잡도를 갖는다.
- 수정 / 삭제 연산 시 트리 깊이 만큼만 비교하면 되기 때문에 $O(\log N)$의 시간 복잡도를 갖는다.

<aside>
💡 완전 이진 트리
- 마지막 레벨을 제외하고 모든 레벨이 완전히 채워진 이진 트리
- 마지막 레벨의 경우 왼쪽부터 채워져 있어야 한다.

</aside>

## 힙 사용 사례

- 우선 순위 큐
- 네트워크 트래픽 제어
- 운영 체제에서의 작업 스케쥴링

## 힙의 구현

- 보통 배열으로 많이 구현한다.
- 구현을 쉽게 하기 위해서 배열의 0 인덱스는 비워둔다.
- 왼쪽 자식의 인덱스 = 부모 인덱스 * 2
- 오른쪽 자식의 인덱스 = 부모 인덱스 * 2 + 1
- 부모 인덱스 = (자식 인덱스 / 2)

### 힙의 삽입

- 새로운 요소를 맨 마지막에 추가한다.
- 새로운 노드와 부모 노드를 비교하여
- 힙의 성질을 만족할 때 까지 부모 노드와 자식 노드를 교환한다.

### 힙의 삭제

- 루트 노드를 제거 한다.
- 루트 노드에 힙의 가장 마지막 노드를 가져온다.
- 힙의 성질을 만족할 때 까지 부모 노드와 자식 노드를 교환한다.

### BST(이진 탐색 트리)와의 비교
- BST의 경우 부모와 자식 뿐만 아니라 형제 노드들 대소 관계가 있다.
- BST의 경우 중복 원소를 허용하지 않지만, heap은 중복 원소를 허용한다.
- BST는 조회에 효율적이고, 힙은 추가 / 삭제를 반복하더라 효율적이다.

# 힙 정렬

- 정렬 하고자 하는 데이터들을 이용해 힙 자료구조를 만든 다음, 
힙에서 모든 원소를 제거하면 정렬 된다.
- 평균적으로 $O(N \log N)$의 시간 복잡도를 갖는다.
- 공간 지역성을 살릴 수 있는 퀵 정렬에 비해 느리기 때문에 잘 사용되진 않는다.
