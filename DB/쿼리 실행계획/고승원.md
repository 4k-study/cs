# 쿼리 실행계획

쿼리 실행 계획 전에 쿼리 실행 절차부터 알아보자

1. 사용자가 요청한 SQL을 분해해서 MySQL서버가 이해할 수 있는 수준으로 분리
2. 1 단계에서 만들어진 파스트리를 확인하고 **실행계획을** 수립한다.
3. 2 단계에서 결정된 실행계획으로 스토리지 엔진으로부터 데이터를 가져온다.

### 실행 계획

MySQL에서 실행계획은 EXPLAIN 키워드를 사용해 볼 수 있다.

EXPLAIN 키워드를 사용해 실행계획을 조회해보자

![image](https://user-images.githubusercontent.com/85796588/236851519-77e831c0-54a8-4338-8e87-4952b50ce5d2.png)

쿼리에서 사용된 (임시 테이블)테이블 개수만큼 데이터가 반환된다.

실행 순서는 위에서 아래로 보면 된다. 실행 순서가 빠를수록 먼저 접근한 테이블이며 느릴수록 쿼리 내부 또는 나중에 접근한 테이블이라고 보면 된다.

**select_type**

- SIMPLE : 단순 select 쿼리
- PRIMARY : UNION 또는 서브쿼리가 포함된 쿼리의 가장 바깥 쿼리
- UNION : union을 사용하는 쿼리의 첫 번째 이후 쿼리
- DERIVED : UNION이 되는 단위 쿼리중 첫 번째 쿼리 (임시 테이블이 만들어 지므로 UNION이 아님), from절에 사용된
- DEPENDENT UNION : UNION이나 UNION ALL로 결합된 쿼리가 외부의 영향을 받는 경우
- UNION RESULT : UNION 사용시 결과를 담아두는 임시 테이블 (별도 id 부여 x)
- SUBQUERY :  from절을 제외한 곳에서 사용하는 서브쿼리
- UNCACHEABLE SUBQUERY : 서브쿼리 사용시 결과를 캐싱하는데, 캐시가 불가능한 경우 사용(컬럼에 스토어드 루틴이 포함, 결과값이 호출때마다 다른경우)

**table**

null, 테이블명, 별칭, 임시테이블(<>) 지칭한다.

**partitions**

어떤 파티션을 사용했는지에 대한 정보

**type**

레코드 스캔 방식을 뜻함.

ALL, system, const, index, range, fulltext, index_subquery등등 존재하는데 ALL을 제외한 모든 것은 인덱스를 사용하는 방법

**possible_keys**

옵티마이저가 최적의 실행계획을 위해 후보로 선정했던 인덱스 목록

**key**

선택되어 쿼리에 사용된 인덱스

**key_len**

인덱스의 각 레코드에서 몇바이트까지 사용했는지

**ref**

참조조건(equal)에 사용된 값

**rows**

예측했던 레코드 건수(정확하지 않음)

**filtered**

사용자에게 전달되기 전에 필터링을 하는데, 이때 얼마나 효율적으로 실행되는지에 대한 지표 

**extra**

성능 관련된 내용으로 여러개 같이 표시된다.
