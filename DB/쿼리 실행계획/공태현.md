## DBMS의 기능

### 쿼리 평가 엔진

사용자로부터 받은 SQL 구문을 분석하고, 어떤 순서로 기억장치의 데이터에 접근할지를 결정한다. 이때 결정되는 계획을 ‘실행 계획’이라고 부른다. 이러한 실행 계획에 기반을 둬서 데이터에 접근하는 방법을 ‘접근 메서드’라고 부른다. 성능과 깊은 연관이 있다.

### 버퍼 매니저

DBMS는 버퍼라는 특별한 용도로 사용하는 메모리 영역을 확보해두는데, 이 메모리 영역을 관리하는 것이 버퍼 매니저이다. 디스크 용량 매니저와 함께 연동되어 작동한다.

### 디스크 용량 매니저

디스크 용량 매니저는 어디에 어떻게 데이터를 저장할지를 관리하며, 데이터의 읽고 쓰기를 제어한다.

### 트랜잭션 매니저와 락 매니저

트랜잭션의 정합성을 유지하면서 실행시키고, 필요한 경우 데이터에 락을 걸어 다른 사람의 요청을 대기시키는 역할을 한다.

### 리커버리 매니저

데이터의 손실을 방지하기 위해 정기적으로 백업하고 문제가 일어났을 때 복구해주는 기능을 수행한다.

## DBMS의 쿼리 처리 흐름

파서 → 옵티마이저(플랜 생성, 비용 평가→ 카탈로그 매니저) → 플랜 평가

### 파서

사용자로부터 입력받은 SQL 구문을 검사한다. 구문이 잘못되었다면 오류를 발생시킨다. 또한 SQL 구문을 정형적인 형식으로 변환시킨다. 이렇게 하면 DBMS 내부에서 일어나는 후속 처리가 효율화된다.

### 옵티마이저

파서에 의해 파싱된 쿼리는 옵티마이저에 도달한다. 옵티마이저는 DBMS의 핵심으로 실행 계획을 최적화해준다. 옵티마이저는 인덱스 유무, 데이터 분산 정도, DBMS 내부 매개변수 등의 조건을 고려하여 **선택 가능한 많은 실행 계획을 작성**하고, 이들의 비용을 연산하고, **가장 낮은 비용을 가진 실행 계획을 선택**한다. 

### 카탈로그 매니저

옵티마이저가 실행 계획을 세울 때 옵티마이저에 중요한 정보를 제공하는 역할을 한다. 카탈로그란 DBMS의 내부 정보를 모아놓은 테이블로, 테이블 또는 인덱스의 통계 정보가 저장되어 있다. 

### 플랜 평가

옵티마이저가 SQL 구문에서 여러 개의 실행 계획을 세운 뒤 그것을 받아 최적의 실행 결과를 선택하게 하는 것을 말한다. 

## 실행 계획

<aside>
💡 데이터베이스 쿼리를 실행하는 방법을 결정하는 일련의 단계를 설명하는 문서

</aside>

### 실행 계획 확인 방법

MySQL은 `EXPLAIN EXTENDED [SQL구문]` 명령어로 SQL 구문에 대한 실행 계획을 확인할 수 있다.

### 실행 계획 기본 출력 포맷

DBMS 종류별로 실행 계획 포맷이 다 같지는 않지만 공통적으로 포함되는 부분이 있다.

- **조작 대상 객체**
    - 테이블, 인덱스, 파티션, 시퀀스처럼 SQL 구문으로 저작할 수 있는 객체를 의미한다.
- **********************************************************객체에 대한 조작의 종류**********************************************************
    - 실행 계획에서 가장 중요한 부분이다.
    - `FULL_TABLE_SCAN`과 같이 어떻게 객체를 조작하는지에 대한 정보를 담고있다.
- ******************************************************************조작 대상이 되는 레코드 수******************************************************************
    - 말 그대로 조작되는 레코드 수를 의미한다.
    - 카탈로그 매니저로부터 얻은 값이기 때문에 실제 레코드 수와 차이가 있을 수 있다.

### SCAN 종류

- **FULL TABLE SCAN :** 테이블의 전체 데이터를 읽어 조건에 맞는 데이터를 추출하는 방식 입니다.
- **ROWID SCAN :** ROWID를 기준으로 데이터를 추출하며 단일 행에 접근하는 방식 중에서 가장 빠릅니다.
- **INDEX SCAN :** 말 그대로 인덱스를 활용하여 원하는 데이터를 추출하는 방식입니다.

### **FULL TABLE SCAN을 타는 상황**

**1.** 조건절에서 비교한 칼럼에 인덱스가 없는 경우

**2.** 조건절에서 비교한 컬럼에 최적화된 인덱스는 있지만 조건에 만족하는 데이터가 테이블의 많은 양을 차지하여 FULL TABLE SCAN이 낫다고 옵티마이저가 판단하는 경우

**3.** 인덱스는 있으나, 테이블의 데이터 자체가 적어 FULL TABLE SCAN이 낫다고 옵티마이저가 판단하는 상황

**4.** 테이블 생성 시 DEGREE 속성 값이 크게 설정되어 있는 경우
