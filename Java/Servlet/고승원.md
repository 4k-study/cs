# Servlet

### Servlet의 탄생

1. 정적 웹페이지에서 동적 웹페이지를 위해 WAS가 사용되고, 이를 처리하기 위한 인터페이스인 CGI가 탄생했다.
2. CGI는 요청마다 프로세스를 만들고, CGI 구현체를 만들기 때문에 더 많은 자원을 사용한다는 문제가 있었다.
3. 이를 해결하기 위한 인터페이스로 Servlet이 탄생하는데, Servlet은 프로세스가 아닌 스레드를 사용하여 요청을 처리하고, 매번 구현체를 만들지 않고 싱글톤 인스턴스를 사용해 요청을 처리해 CGI의 문제를 해결했다.
    
    이것 외에도 메세지 파싱과 HTTP 메서드 분기처리등 편의성이 추가되었다.
    
4. 하지만 Servlet또한 문제점이 있었는데, Servlet은 요청마다 싱글톤을 만들어서 사용했기 때문에 인스턴스가 여러개 생성되었다.
5. 4에서의 문제점은 Front Controller 패턴으로 해결하게 된다.
6. 이는 스프링의 Dispatcher Servlet의 전신이 된다.

### Servlet의 생성과 삭제

Servlet은 Servlet Container(Tomcat)가 관리한다.

Init : 요청이 생기면, 해당하는 Servlet을 찾고, 없다면 생성한다.

Service : 해당하는 HTTP 메서드에 따라 비즈니스 로직을 호출한다.

Destroy : Container가 종료될때 destroy 메서드를 호출해서 삭제한다.

### Spring MVC의 Dispatcher Servlet

스프링의 Dispatcher Servlet 덕분에 개발자는 비즈니스 로직에만 집중할 수 있다. 어떻게 진행되는지 알아보자.

![image](https://github.com/4k-study/cs/assets/85796588/a8da8bb8-e81d-45d2-baeb-0135ae4e0044)

핸들러와 컨트롤러는 조금 다른 개념이다. 핸들러는 요청을 처리하는 일반적인 개념이고, 컨트롤러는 MVC에서 요청을 처리하고 비즈니스 로직을 수행하는 요소이다.

1. 모든 요청은 DispatcherServlet이 받는다.
2. 받은 요청을 처리할 수 있는 핸들러 매핑 정보(처리할 수 있는지)를 확인한다.
3. 요청을 컨트롤러로 위임할 핸들러 어댑터를 찾아서 전달한다.
4. 핸들러 어댑터가 핸들러에 요층을 위임한다.
5. 컨트롤러에서 비즈니스 로직을 수행하고 반환값을 반환한다.
6. 핸들러 어댑터가 반환값을 처리해 디스패처 서블렛에 보낸다.
7. 뷰가 있는경우 뷰에 담아 반환하고 없는 경우 클라이언트로 반환한다.
