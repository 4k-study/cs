# 질문

- 멀티스레드 방식으로 프로그래밍을 하면 어떤 장점이 있나요?
    
    ```java
    1. 응답성 : 프로그램의 일부분(스레드)이 중단되거나 긴 작업을 수행하더라도 프로그램의 수행이
    계속 되어 사용자에 대한 응답성이 증가합니다.
    2. 경제성 : 프로세스 내 자원들과 메모리를 공유하기 때무에 메모리 공간과 시스템 자원 소모가
    줄어듭니다. 스레드 간 통신이 필요한 경우에도 쉽게 데이터를 주고 받을 수 있고 프로세스의
    컨텍스트 스위칭과 달리 스레드 간의 컨텍스트 스위칭은 캐시를 비울 필요가 없어 더 빠릅니다.
    3. 멀티프로세서 활용 : 다중 CPU 구조에서는 각각의 스레드가 다른 프로세서에서 병렬로 수행될
    수 있으므로 병렬성이 중가한다.
    ```
    
- Runnable 인터페이스를 구현한 객체에서 Exception을 발생시킬 수 없는게 맞나요?
    
    ```java
    throws 키워드가 존재하지 않기에 checked exception은 던질 수 없지만 unchecked exception은
    던질 수 있습니다. 또 checked exception이 발생하더라도 내부적으로 try-catch를 이용하여
    해당 예외를 잡아서 처리해줄 수 있습니다.
    ```
    
- Callable 반환값은 어떻게 얻나요?
    
    ```java
    ExcutorService의 submit 메서드의 인자로 Callable 구현체를 넣음으로써 작업을 수행할 수 있고
    완료 시 Future 객체를 반환하는 데 해당 객체를 통해서 반환 결과 값을 얻을 수 있습니다.
    ```
    
- ExecutorService가 뭔가요?
    
    ```java
    해당 서비스는 간단하게 쓰레드풀을 생성하여서 병렬처리를 원활하게 해주는 서비스 객체입니다.
    ```
    
- CompletableFuture 이것도 설명 가능한가요?
    
    ```java
    기존 Future 인터페이스를 이용했을 때 문제점들이 존재했는데 
    - 예외 처리용 API를 제공하지 않는다는 점
    - 여러 Future를 조합하기 어렵다는 점
    - Future에서 반환하는 결과값을 가지고 무언가를 하는 작업들은 get 메서드 뒤에 와야한다는 점
    이었습니다. 근데 저 get 메서드는 블로킹 콜이기에 여러 작업을 수행할 때 어려움이 있었습니다.
    CompletableFuture는 자바에서 비동기 프로그래밍을 가능하게 하는 인터페이스로
    - Future
    - CompletionStage
    	- 외부에서 명시적으로 Complete를 시킬 수 있습니다.
    	- 응답이 오지 않으면 그냥 기본값으로 미리 캐시해둔 값이나 특정한 값을 반환하게 만들 수 있습니다.
    이러한 기능들을 구현하여 명시적으로 Executor를 만들어서 쓸 필요가 없고 CompletableFuture만
    가지고도 비동기적으로 작업들을 실행할 수 있습니다.
    ```
    
- Future로 반환값을 얻으려면 get() 메소드를 사용하는데 이때 어떤 특징이 있나요?
    
    ```java
    get 메서드는 블록킹 콜이라서 콜된 스레드가 동작이 끝날 때까지 대기하는 특징을 가집니다.
    ```
