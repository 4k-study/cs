## JVM의 구성

### 클래스 로더

자바는 컴파일이 아니라 **런타임 단계**(바이트 코드를 실행할 때)에 클래스를 로드하고 링크하는 특징이 있다. 이 동적 로드를 담당하는 부분이 JVM의 클래스 로더이다. 클래스 로더는 로딩, 링크, 초기화 단계로 나뉘어져 있다.

- 로딩
    - 자바 바이트 코드(.class)를 메모리의 메소드 영역에 저장한다.
    - 각 자바 바이트 코드는 JVM에 의해 메소드 영역에 다음 정보들을 저장한다.
        - 로드된 클래스를 비롯한 가의 부모 클래스의 정보
        - 클래스 파일과 Class, Interface, Enum의 관련 여부
        - 변수나 메소드 등의 정보
- 링크
    - 검증 : 읽어 들인 클래스가 자바 언어 명세 및 JVM 명세에 명시된 대로 잘 구성되어 있는지 검사
    - 준비 : 클래스가 필요로 하는 메모리를 할당하고 준비
    - 분석 : Symbolic Memory Reference를 메소드 영역에 있는 실제 Reference로 교체
        - `Book book = new Book()` 이라는 코드가 있을 때 `book`이라는 참조 변수가 실제 힙 영역에 있는 `Book` 클래스 객체를 가르킬 수 있도록 연결하는 과정이다.
- 초기화 : 클래스 변수들을 적절한 값으로 초기화한다. 즉, `static` 필드들이 설정된 값으로 초기화한다.

### 실행 엔진

메모리에 적재된 **바이트 코드를 기계어로 변경**하여 명령어 단위로 실행 및 **바이트 코드를 운영체제에 맞게 해석**해주는 역할을 수행한다. 실행 엔진이 바이트 코드를 명령어 단위로 읽어서 수행하는데 크게 두 가지 방식이 사용된다.

1. 인터프리터
    1. 런타임 중에 바이트 코드를 한 줄씩 읽고 실행한다.
    2. 컴파일보다 속도가 느리다.
2. **JIT(Just In Time)**
    1. 인터프리터의 속도 이슈를 해결하기 위해 같이 사용한다.
    2. 자주 실행되는 바이트 코드 영역을 런타임 중에 기계어로 컴파일하여 사용한다.

### 런타임 데이터 영역

JVM이 프로그램을 수행하기 위해 **운영체제로부터 별도로 할당받은 메모리 공간**을 의미한다. 런타임 데이터 영역은 크게 5가지 영역으로 나눌 수 있다.

- **PC 레지스터 :** 쓰레드가 시작될 때 생성되며 각 쓰레드마다 하나씩 존재한다. 쓰레드가 **어떤 부분을 어떤 명령으로 실행해야할 지에 대한 기록**을 하는 부분으로 현재 수행 중인 JVM 명령의 주소를 갖는다.
- **JVM 스택 영역 :** 각 쓰레드마다 하나씩 존재하면 쓰레드가 시작될 때 생성된다. JVM 스택 영역은 메소드를 호출할 때마다 프레임을 추가하고 메소드가 종료되면 해당 프레임을 제거하는 동작을 수행한다. 프레임 내부에는 로컬 변수 스택이 있는데 기본 타입 변수와 참조 타입 변수가 추가되거나 제거된다. 변수가 이 영역에 생성되는 시점은 초기화가 될 때이다. 또 **호출된 메소드의 매개변수, 지역변수, 리턴 값 들을 임시로 저장**한다.
- **네이티브 메소드 스택 :** 바이트 코드가 아닌 **실제 실행할 수 있는 기계어로 작성된 프로그램을 실행**시키는 영역이다. 즉, 자바가 아닌 다른 언어로 작성된 코드를 위한 공간이다. 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역이다.
- **메소드 영역 (클래스 영역, 스택 영역, 정적 영역) :** 모든 스레드가 공유하는 영역으로 JVM이 시작될 때 생성된다. 메소드 영역은 **클래스들을 클래스 로더로 읽어 클래스별로 런타임 상수풀, 필드 데이터, 메소드 데이터, 메소드 코드, 생성자 코드 등을 분류해서 저장**한다.
- **힙 영역 :** 모든 스레드가 공유하는 영역으로 **객체를 저장하는 가상 메모리 공간**이다. new 연산자로 생성된 객체와 배열을 저장한다. **클래스 영역에 올라온 클래스들만 객체로 생성할 수 있다.** **가비지 콜렉터가 작동**하는 영역이다.
