1. N+1문제를 해결하기 위해서 어떤 전략을 사용해보셨나요?
```
finaAll() 메서드로 엔티티를 조회할 때 N:1 관계로 연관관계가 있는 엔티티의 N+1 문제를 막기 위해 fetch join 을 사용한 경험이 있습니다.
```
<br>

2. 다른 전략이 아닌 fetch join 을 이용한 이유는 뭔가요??
```
batchSize 를 활용하는 것보다 쿼리가 적고,
EntityGraph 의 경우 기본적으로 left outer join 를 사용하하여 불필요한 정보도 가져오기에 fetch join 을 사용하였습니다.
```
<br>

3. 어떤 경우든 fetch 조인 전략을 이용하면 N+1 문제를 해결할 수 있나요?
```
fetch join 도 한계가 있습니다.
둘 이상의 컬렉션에서 fetch join 을 사용할 수 없는 문제와, 일대다 관계에서 페이징 시 성능 이슈가 있는 점이 그렇습니다.
```
<br>

4. 둘 이상의 컬렉션에 fetch join 을 왜 사용할 수 없나요? 어떤 문제가 발생하는거죠??
```
둘 이상 컬렉션과 fetch join 을 진행 시 카테시안 곱이 되어 데이터 정합성이 맞지 않습니다. 
그렇기에 JPA 에서 둘 이상의 컬렉션을 fetch join 시 MultipleBagFetchException 이 발생합니다.
```
<br>

5. 일대다 관계를 가지는 엔티티를 fetch join 할 때, 발생할 수 있는 문제는 뭐가 있을까요?
```
일대다의 경우는 일에 다를 끼워 넣는 것이기에 DB 에서 다만큼의 데이터가 뻥튀기됩니다.
별도의 처리를 하지 않으면 엔티티도 뻥튀기 된 상태로 받게됩니다.
이를 본 의도대로 사용하려면 distinct 키워드로 엔티티의 중복을 제거해줘야 합니다.
DB 에서는 행 데이터가 다르기에 distinct 가 동작하지 않지만 엔티티에서는 JPA 가 식별자로 걸러서 중복을 제거할 수 있습니다. 
```
<br>

6. 일대다 관계에서 fetch join 으로 페이징할 때 발생할 수 있는 문제에 대해 알려주세요.
```
일대다의 경우는 일에 다를 끼워 넣는 것이기에 다만큼의 데이터가 뻥튀기됩니다.
예를 들어보자면, 팀과 회원의 일대다 관계를 예로 들어보겠습니다.
팀 A 에 회원 1, 2 가 있다고 했을 때, 개발자가 팀 A 의 정보를 보고 싶다면 페이징 limit 을 1 로 줄 것입니다.
하지만, DB 에서는 데이터가 뻥튀기가 되어서 limit 1로 조회하면 (팀 A, 회원 1) 정보만 조회됩니다.
JPA 에서는 이렇게 뻥튀기되는 데이터에 맞게 limit 을 조정할 수 없기에 limit 없이 모든 연관된 데이터를 메모리에 올려서 메모리 상에서 페이징합니다.
이는 데이터가 1000 만 건이라면, 1000 만 건을 전부 메모리에 올리게 되는 위험한 일을 야기할 수 있습니다.
그래서 일대다 관계에서 페이징을 하고 싶다면 @BatchSize 를 이용하거나 다대일 관계로 뒤집어서 조회하고 페이징하는 것이 좋습니다.
```
<br>

7. 프록시를 사용해서 N+1이 생기는데 애초에 프록시를 사용안하면 되는 거 아닌가요?
```
JPQL 을 이용하면 SQL 로 변환 시 조회하려는 엔티티 기준으로만 쿼리를 만듭니다. 
그렇기에 엔티티를 초기에 바인딩 시에 연관된 엔티티를 가져올 수 없기에 프록시 사용이 강제됩니다.
```
<br>
