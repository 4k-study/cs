JPA에서 엔티티간 연관관계로 인해서 발생하는 문제로 특정 엔티티를 조회했을 때 연관관계가 설정된 엔티티를 조회할 경우에 조죄된 데이터 갯수만큼 연관관계의 조회 쿼리가 추가로 발생하여 데이터를 읽어오는 문제입니다.

### 발생 이유

JPA를 이용하면 sql문을 직접 짜는 것이 아니라 JPA 내부적으로 JPQL을 이용해서 쿼리를 날리게 되는데 이때 JPQL이 글로벌 페치 전략을 무시하고 프록시 객체로 연관관계 엔티티에 대한 바이딩을 하기에 N개의 추가적인 쿼리가 발생합니다.

### 해결 방안

- @BetchSize 어노테이션 이용
- fetchmode subselect 이용 이는 서브 쿼리를 이용해서 데이터를 조회하게 만들 수 있습니다. (@Fetch 어노테이션)
- fetch join을 이용해서 JPQL을 개발자가 직접 짜서 연관관계로 설정된 데이터를 조회시점에 한번에 들고 오게 만들 수 있습니다.

### fetch join 특징 및 한계

- 컬렉션을 페치 조인하는 경우의 페이징 사용 불가능
    - 일대일, 다대일 같은 단일 값 연관 필드들은 페치 조인해도 페이징이 가능하지만 일대다, 다대다는 페치 조인 페이징이 불가능합니다.
    - Hibernate에서는 경고 로그를 남기고 메모리에서 페이징을 수행합니다. 이는 상당히 위험합니다.
- 페치 조인 대상에 별칭 사용
    - Hibernate에서 페치 조인 대상에 별칭을 줄 수 있지만 사용을 지양해야 합니다.
    - 객체 그래프라는 것이 데이터를 전부 다 조회하는 것을 의미하는데 여기서 일부만 걸러서 조회하는게 좋아보이지만 정합성 관련 이슈로 문제가 될 수 있다.
    - 팀과 연관된 멤버를 row 기준 5개만 가져오고 싶다고 가정한다면 이럴 땐 Team을 조회해서 데이터를 뽑는 것이 아닌 Member 자체를 조회해서 데이터를 걸러내는 방식으로 진행해야 한다.
- 둘 이상의 컬렉션에 페치 조인 사용
    - 1:N 관계는 데이터 뻥튀기가 발생하는데 둘 이상의 컬렉션에 페치 조인 사용 시 데이터 정합성에 문제가 발생할 수 있습니다.

이런 문제들을 해결하기 위해서는

- 일대다 관계를 다대일 관계로 방향을 뒤집아서 조회하고 페이징 처리를 합니다.
- fetch join을 제거하고 @BetchSize를 이용해서 SQL IN 절을 통해 SQL의 수를 줄일 수 있습니다.

### 왜 fetch join과 페이징을 OneToMany, ManyToMany 관계에서 사용하지 못하게 막았을까?

- https://junhyunny.github.io/spring-boot/jpa/jpa-fetch-join-paging-problem/#closing
- 해당 글에서 보면 영한님께서 데이터의 수가 증가하기 때문이라고 합니다.
    - 좀 더 자세하게 팀과 멤버가 1:N 관계인 경우에 멤버의 정보를 가져오고 여기에 대한 페이징을 수행한다 가정해보자.
    - 그 경우 A, B, C라는 3개의 팀이 있고 3, 4, 5명의 멤버가 속해있을 때 join을 하게 되면 원래 3개였던 팀 데이터가 멤버 수를 곱한 만큼 늘어난다. 데이터의 수가 증가하는 것이다. 그러면 어떤 데이터를 기준으로 JPA가 페이징을 수행해야 하는 지 알 수 없게 되기에 이를 막아두었다.
- 그래서 fetch join, pagination을 같이 사용하면 경고만 뜨는데 실제로 limit, offset이 적용되지 않은 쿼리가 날라가서 이제 전체 데이터를 메모리로 가져오게 됨.
