## 정의

엔티티를 영구 저장하는 환경이라는 뜻이다.

## 특징

- 식별자 값
    - 영속성 컨텍스트는 엔티티를 식별자 값으로 구분한다. 그래서 영속 상태의 엔티티는 반드시 식별자 값이 있어야한다.
- 데이터베이스 저장
    - 트랜잭션이 커밋되는 시점에 flush 를 통해 DB 에 저장된다.
- 1차 캐시
    - 매번 조회 시마다 DB 에 쿼리를 날려 조회를 하면 효율이 떨어진다. JPA 는 영속성 컨텍스트 안의 1차 캐시 (메모리) 에 엔티티를 담아둔다. 찾으려는 엔티티가 이미 1차 캐시에 있다면 DB 에 쿼리를 날리지 않고 1차 캐시에서 가져온다. 없다면 DB 에서 조회하고 1차 캐시에 저장하고 반환한다.
- 동일성 보장
    - 영속성 컨텍스트는 같은 조회를 반복적으로 호출해도 동일성을 보장한다.
- 쓰기 지연
    - 쓰기 쿼리가 있을 때마다 매번 쿼리를 날리면 효율이 떨어진다. 그리고 1차 캐시가 있으므로 그럴 필요도 없다. 또, DB 트랜잭션이 커밋되지 않는다면 쿼리를 매번 보내도 반영되지 않는다. 그래서 영속성 컨텍스트는 내부 쿼리 저장소에 SQL 을 모아두고 트랜잭션을 커밋할 때 모아둔 쿼리를 DB 에 보내고 커밋한다.
- 변경 감지
    - JPA 는 엔티티를 영속성 컨텍스트에 보관 시, 최초 상태를 복사해서 저장해둔다. 이를 스냅샷이라고 한다. 플러시 시점에 스냅샷과 비교하여 변경된 엔티티를 찾고 있다면 플러시 전에 수정 쿼리를 만들어서 쓰기 지연 저장소에 넣는다.
- 지연 로딩
    - 연관된 엔티티를 매번 DB 에서 가져와서 저장해놓을 필요 없습니다. JPA 는 프록시 객체로 대체하고 실제로 그 값이 사용될 때, DB 에서 호출합니다.

## 플러시

영속성 컨텍스트와 DB 를 동기화하는 것을 의미한다.

영속성 컨텍스트가 플러시하는 방법은 아래의 3가지다.

- 직접 호출
- 트랜잭션 커밋 전 플러시 자동 호출
- JPQL 실행 시 자동 호출
    - 트랜잭션 커밋 전에 특정 엔티티를 영속 상태로 만들고 JPQL 로 조회했다고 가정해보자. JPQL 은 SQL 로 변환되어서 DB 에서 직접 조회하는데, 아까 영속 상태로 만든 엔티티는 커밋되지 않았으므로 조회가 안된다. 그러니까 JPQL 실행 전에 플러시를 해줘서 동기화를 해주어야한다.
    - 근데, 정확히 쓰기 지연 저장소에서 JPQL 과 연관 있는 쿼리들만 플러시한다.
